<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Global Water Level Slider</title>
    <!-- Ocean wave favicon -->
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåä</text></svg>"
    />
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
    <link
      href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
      }
      #cesiumContainer {
        width: 100%;
        height: 100vh;
      }

      /* Full-width slider at top of screen */
      #sliderContainer {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        background: rgba(42, 42, 42, 0.9);
        padding: 0.75rem 1.5rem 1rem 1.5rem;
        z-index: 100;
        -webkit-backdrop-filter: blur(0.3125rem);
        backdrop-filter: blur(0.3125rem);
      }
      #sliderContainer input[type='range'] {
        width: 100%;
        margin: 0.5rem 0;
        height: 8px;
        cursor: pointer;
      }
      .slider-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.8em;
        color: #aaa;
      }
      .slider-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: white;
        margin-bottom: 0.25rem;
      }
      .slider-header h3 {
        margin: 0;
        font-size: 1em;
      }
      #currentHeight {
        font-weight: bold;
        color: #4db8ff;
        font-size: 1.2em;
      }

      /* Floating info panel (bottom-left) */
      #infoPanel {
        position: absolute;
        bottom: 1.25rem;
        left: 1.25rem;
        background: rgba(42, 42, 42, 0.8);
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        color: white;
        z-index: 100;
        -webkit-backdrop-filter: blur(0.3125rem);
        backdrop-filter: blur(0.3125rem);
        font-size: 0.85em;
      }

      /* Accessibility: visually hidden but screen reader accessible */
      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      #infoPanel p {
        margin: 0.25rem 0;
      }
      #changeTokenBtn {
        margin-top: 0.5rem;
        padding: 0.3rem 0.6rem;
        font-size: 0.75em;
        background: #555;
        color: #ccc;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      #changeTokenBtn:hover {
        background: #666;
      }
    </style>
  </head>
  <body>
    <!-- Info panel (bottom-left) -->
    <div id="infoPanel">
      <p><strong>Global Flooding Visualization</strong></p>
      <p>Use slider or ‚Üê ‚Üí arrow keys (10ft steps)</p>
      <div style="margin: 0.5rem 0">
        <label
          style="
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
          "
        >
          <input type="checkbox" id="toggleImagery" checked />
          <span>Show Satellite Imagery</span>
        </label>
      </div>
      <p
        id="debugInfo"
        style="font-size: 0.75em; color: #aaa; margin-top: 0.5rem"
      ></p>
      <p
        id="testStatus"
        style="
          font-size: 0.75em;
          color: #0f0;
          margin-top: 0.5rem;
          display: none;
        "
      ></p>
      <button type="button" id="runTestBtn" style="margin-top: 0.5rem">
        Run Diagnostic Test
      </button>
      <button type="button" id="changeTokenBtn">Change Cesium Token</button>
    </div>

    <!-- Full-width slider (bottom) -->
    <div id="sliderContainer">
      <div class="slider-header">
        <h3>Water Level</h3>
        <span id="currentHeight">0 ft</span>
      </div>
      <label for="heightSlider" class="visually-hidden"
        >Water Level Slider</label
      >
      <input
        type="range"
        id="heightSlider"
        min="-37417"
        max="30032"
        value="0"
        step="50"
        title="Adjust water level"
      />
      <div class="slider-labels">
        <span>-37,417 ft (Deep Ocean)</span>
        <span>+30,032 ft (Mt. Everest)</span>
      </div>
    </div>

    <div id="cesiumContainer"></div>

    <script>
      // 1. SETUP: Get Cesium token from local storage or prompt user
      const CESIUM_TOKEN_KEY = 'cesiumIonAccessToken';

      function getCesiumToken() {
        let token = localStorage.getItem(CESIUM_TOKEN_KEY);
        if (!token) {
          token = prompt(
            'Please enter your Cesium ion Access Token.\n\n' +
              'You can get a free token at: https://ion.cesium.com/tokens\n\n' +
              'This will be saved in your browser for future visits.',
          );
          if (token) {
            localStorage.setItem(CESIUM_TOKEN_KEY, token.trim());
          }
        }
        return token;
      }

      function clearCesiumToken() {
        localStorage.removeItem(CESIUM_TOKEN_KEY);
        location.reload();
      }

      const cesiumToken = getCesiumToken();
      if (!cesiumToken) {
        document.body.innerHTML =
          '<div style="padding: 20px; font-family: sans-serif;">' +
          '<h2>Cesium Token Required</h2>' +
          '<p>A Cesium ion access token is required to use this application.</p>' +
          '<p>Get a free token at: <a href="https://ion.cesium.com/tokens" target="_blank">https://ion.cesium.com/tokens</a></p>' +
          '<button onclick="location.reload()">Try Again</button>' +
          '</div>';
        throw new Error('No Cesium token provided');
      }

      Cesium.Ion.defaultAccessToken = cesiumToken;

      // 2. INITIALIZE VIEWER
      const viewer = new Cesium.Viewer('cesiumContainer', {
        baseLayerPicker: true,
        animation: false,
        timeline: false,
      });

      // 3. ENABLE DEPTH TESTING
      viewer.scene.globe.depthTestAgainstTerrain = true;

      // 4. DATA LOGIC
      const FEET_TO_METERS = 0.3048;
      let waterHeightFeet = 0; // Starting at Sea Level (in feet)
      let terrainReady = false;
      const debugInfo = document.getElementById('debugInfo');

      // Set terrain with Cesium World Bathymetry (asset ID 2426648)
      // This includes underwater ocean floor topography
      // IMPORTANT: We must wait for terrain to load before applying elevation band material!

      async function loadTerrain() {
        const terrainOptions = {
          requestWaterMask: true,
          requestVertexNormals: true,
        };

        // Try Cesium World Bathymetry first (asset ID 2426648)
        try {
          console.log(
            'Attempting to load Cesium World Bathymetry (asset 2426648)...',
          );
          debugInfo.textContent = 'Loading Cesium World Bathymetry...';
          const bathymetryTerrain =
            await Cesium.CesiumTerrainProvider.fromIonAssetId(
              2426648,
              terrainOptions,
            );
          viewer.terrainProvider = bathymetryTerrain;
          console.log('‚úì Cesium World Bathymetry loaded successfully');
          debugInfo.textContent = 'Terrain: Cesium World Bathymetry ‚úì';
        } catch (bathymetryError) {
          console.warn(
            'Failed to load Cesium World Bathymetry:',
            bathymetryError,
          );
          console.log(
            'Falling back to standard Cesium World Terrain (asset 1)...',
          );
          debugInfo.textContent =
            'Bathymetry unavailable, loading World Terrain...';

          // Fall back to standard Cesium World Terrain (asset ID 1)
          try {
            const worldTerrain =
              await Cesium.CesiumTerrainProvider.fromIonAssetId(
                1,
                terrainOptions,
              );
            viewer.terrainProvider = worldTerrain;
            console.log('‚úì Cesium World Terrain loaded successfully');
            debugInfo.textContent = 'Terrain: Cesium World Terrain ‚úì';
          } catch (terrainError) {
            console.error('Failed to load any terrain:', terrainError);
            debugInfo.textContent = 'ERROR: Failed to load terrain!';
            alert(
              'Failed to load terrain data. Please check your Cesium ion access token and ensure it is valid.',
            );
            return; // Don't apply flood material if no terrain
          }
        }

        // Terrain loaded successfully - now apply flood material
        terrainReady = true;
        console.log('Terrain ready, applying flood material...');
        viewer.scene.globe.material = createFloodMaterial(
          waterHeightFeet * FEET_TO_METERS,
        );
        console.log(
          'Flood material applied with water level:',
          waterHeightFeet,
          'ft',
        );

        // Update debug info with terrain height after a delay
        setTimeout(updateDebugInfo, 2000);
      }

      // Start loading terrain
      loadTerrain();

      // 5. SATELLITE IMAGERY TOGGLE
      const imageryToggle = document.getElementById('toggleImagery');
      let baseLayer = null;

      // Store reference to base imagery layer
      viewer.scene.globe.tileLoadProgressEvent.addEventListener(function () {
        if (!baseLayer && viewer.imageryLayers.length > 0) {
          baseLayer = viewer.imageryLayers.get(0);
        }
      });

      imageryToggle.addEventListener('change', function () {
        if (baseLayer) {
          baseLayer.show = this.checked;
        } else if (viewer.imageryLayers.length > 0) {
          viewer.imageryLayers.get(0).show = this.checked;
        }
      });

      // 6. CUSTOM MATERIAL SHADER FOR TERRAIN-BASED FLOODING
      // This uses materialInput.height to access actual terrain elevation
      // and compares it to the water level to determine flooding.
      // Based on approach from Cesium Community forum by Sean Lilley.

      // Create a color ramp canvas for the elevation ramp
      function createColorRampCanvas(waterLevelMeters) {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');

        // Create gradient from deep ocean to surface to land (transparent)
        const gradient = ctx.createLinearGradient(0, 0, 256, 0);

        // Calculate positions: 0 = minHeight, 1 = maxHeight
        const minHeight = -12000; // meters
        const maxHeight = 10000; // meters
        const range = maxHeight - minHeight;

        // Water level normalized position
        const waterPos = (waterLevelMeters - minHeight) / range;
        const waterPosSlightlyBelow = Math.max(0, waterPos - 0.001);
        const waterPosSlightlyAbove = Math.min(1, waterPos + 0.001);

        // Deep ocean - dark blue
        gradient.addColorStop(0, 'rgba(0, 30, 80, 0.8)');

        // Mid ocean - medium blue
        if (waterPosSlightlyBelow > 0.01) {
          gradient.addColorStop(
            waterPosSlightlyBelow * 0.5,
            'rgba(0, 60, 140, 0.7)',
          );
        }

        // Just below water surface - lighter blue
        gradient.addColorStop(
          Math.max(0.01, waterPosSlightlyBelow),
          'rgba(0, 100, 200, 0.6)',
        );

        // Sharp transition at water level
        gradient.addColorStop(waterPos, 'rgba(0, 120, 220, 0.5)');
        gradient.addColorStop(waterPosSlightlyAbove, 'rgba(0, 0, 0, 0)');

        // Above water - fully transparent
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 1);

        return canvas;
      }

      function createFloodMaterial(waterLevelMeters) {
        const minHeight = -12000; // meters (about -39,000 ft)
        const maxHeight = 10000; // meters (about +32,800 ft)

        // Use ElevationRamp material type which is built into CesiumJS
        // and properly samples terrain height
        return Cesium.Material.fromType('ElevationRamp', {
          image: createColorRampCanvas(waterLevelMeters),
          minimumHeight: minHeight,
          maximumHeight: maxHeight,
        });
      }

      // NOTE: Initial flood material is now applied in the terrain provider callback above
      // to ensure terrain is loaded before applying the elevation band material.

      // Update debug info with terrain height at camera look point
      function updateDebugInfo() {
        const camera = viewer.camera;
        const ray = camera.getPickRay(
          new Cesium.Cartesian2(
            viewer.canvas.clientWidth / 2,
            viewer.canvas.clientHeight / 2,
          ),
        );
        if (ray) {
          const position = viewer.scene.globe.pick(ray, viewer.scene);
          if (position) {
            const cartographic = Cesium.Cartographic.fromCartesian(position);
            const heightMeters = cartographic.height;
            const heightFeet = heightMeters / FEET_TO_METERS;
            debugInfo.textContent =
              'Terrain at center: ' +
              heightFeet.toFixed(0) +
              ' ft (' +
              heightMeters.toFixed(1) +
              ' m)';
          }
        }
      }

      // Update debug info periodically
      setInterval(updateDebugInfo, 500);

      // 6. UI INTERACTION
      const slider = document.getElementById('heightSlider');
      const label = document.getElementById('currentHeight');

      function formatNumber(num) {
        return num.toLocaleString('en-US');
      }

      function updateWaterLevel(feet) {
        waterHeightFeet = feet;
        // Convert feet to meters
        const waterHeightMeters = waterHeightFeet * FEET_TO_METERS;
        // Update the elevation band material
        viewer.scene.globe.material = createFloodMaterial(waterHeightMeters);
        // Update the text label
        label.innerText = formatNumber(waterHeightFeet) + ' ft';
      }

      slider.addEventListener('input', function () {
        updateWaterLevel(parseFloat(this.value));
      });

      // Keyboard arrow support for precise 10ft increments
      // Works when slider is focused OR when pressing arrows anywhere on page
      const ARROW_INCREMENT = 10; // feet
      const MIN_LEVEL = -37417;
      const MAX_LEVEL = 30032;

      function adjustWaterLevel(delta) {
        let newValue = waterHeightFeet + delta;
        newValue = Math.max(MIN_LEVEL, Math.min(MAX_LEVEL, newValue));
        slider.value = newValue;
        updateWaterLevel(newValue);
      }

      // Global keyboard listener for arrow keys
      document.addEventListener('keydown', function (e) {
        if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
          e.preventDefault();
          adjustWaterLevel(ARROW_INCREMENT);
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
          e.preventDefault();
          adjustWaterLevel(-ARROW_INCREMENT);
        }
      });

      // 7. LOCAL STORAGE FOR CAMERA POSITION & WATER LEVEL
      const STORAGE_KEY = 'floodingViewerState';

      function saveState() {
        const camera = viewer.camera;
        const state = {
          position: {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
          },
          heading: camera.heading,
          pitch: camera.pitch,
          roll: camera.roll,
          waterHeightFeet: waterHeightFeet,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }

      function loadState() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          try {
            const state = JSON.parse(saved);
            viewer.camera.setView({
              destination: new Cesium.Cartesian3(
                state.position.x,
                state.position.y,
                state.position.z,
              ),
              orientation: {
                heading: state.heading,
                pitch: state.pitch,
                roll: state.roll,
              },
            });
            // Restore water level
            if (state.waterHeightFeet !== undefined) {
              slider.value = state.waterHeightFeet;
              updateWaterLevel(state.waterHeightFeet);
            }
            return true;
          } catch (e) {
            console.warn('Failed to load saved state:', e);
          }
        }
        return false;
      }

      // Try to load saved state, otherwise default to Utah
      if (!loadState()) {
        viewer.camera.setView({
          destination: Cesium.Cartesian3.fromDegrees(-111.5, 39.5, 500000), // Utah
          orientation: {
            heading: 0.0,
            pitch: -0.7, // Looking down at an angle
            roll: 0.0,
          },
        });
      }

      // Save state when camera moves or water level changes
      viewer.camera.moveEnd.addEventListener(saveState);
      slider.addEventListener('change', saveState);

      // Change token button
      document
        .getElementById('changeTokenBtn')
        .addEventListener('click', clearCesiumToken);

      // ========================================
      // AUTOMATED DIAGNOSTIC TESTING
      // ========================================
      const testStatus = document.getElementById('testStatus');
      const runTestBtn = document.getElementById('runTestBtn');

      // Test locations with known elevations
      const TEST_LOCATIONS = [
        { name: 'Miami Beach', lon: -80.13, lat: 25.79, expectedElev: 2 },
        { name: 'New Orleans', lon: -90.07, lat: 29.95, expectedElev: -2 },
        { name: 'Denver CO', lon: -104.99, lat: 39.74, expectedElev: 5280 },
        { name: 'Death Valley', lon: -116.87, lat: 36.23, expectedElev: -282 },
        { name: 'Atlantic Ocean', lon: -50.0, lat: 30.0, expectedElev: -15000 },
        {
          name: 'Pacific Mariana',
          lon: 142.2,
          lat: 11.35,
          expectedElev: -36000,
        },
      ];

      // Test elevations in feet
      const TEST_ELEVATIONS = [
        -100, -50, -10, 0, 10, 20, 23, 30, 33, 40, 50, 100, 500, 1000, 5000,
      ];

      async function sampleTerrainAt(lon, lat) {
        const cartographic = Cesium.Cartographic.fromDegrees(lon, lat);
        try {
          const positions = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            [cartographic],
          );
          return positions[0].height;
        } catch (e) {
          return null;
        }
      }

      async function captureScreenshot(filename) {
        return new Promise((resolve) => {
          viewer.render();
          setTimeout(() => {
            const canvas = viewer.scene.canvas;
            const dataUrl = canvas.toDataURL('image/png');
            resolve({ filename, dataUrl });
          }, 100);
        });
      }

      async function getColorAtCenter() {
        const canvas = viewer.scene.canvas;
        const ctx = canvas.getContext('webgl2') || canvas.getContext('webgl');
        const x = Math.floor(canvas.width / 2);
        const y = Math.floor(canvas.height / 2);
        const pixels = new Uint8Array(4);
        ctx.readPixels(x, y, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, pixels);
        return { r: pixels[0], g: pixels[1], b: pixels[2], a: pixels[3] };
      }

      async function runDiagnosticTest() {
        testStatus.style.display = 'block';
        testStatus.textContent = 'Starting diagnostic test...';
        runTestBtn.disabled = true;

        const results = {
          timestamp: new Date().toISOString(),
          cesiumVersion: Cesium.VERSION,
          terrainProvider: viewer.terrainProvider.constructor.name,
          terrainReady: viewer.terrainProvider.ready,
          globeMaterial: viewer.scene.globe.material ? 'Applied' : 'None',
          depthTestEnabled: viewer.scene.globe.depthTestAgainstTerrain,
          locationTests: [],
          elevationTests: [],
          screenshots: [],
        };

        // Test 1: Sample terrain at known locations
        testStatus.textContent = 'Testing terrain heights at locations...';
        for (const loc of TEST_LOCATIONS) {
          const measuredHeight = await sampleTerrainAt(loc.lon, loc.lat);
          results.locationTests.push({
            name: loc.name,
            lon: loc.lon,
            lat: loc.lat,
            expectedElevFt: loc.expectedElev,
            measuredHeightM: measuredHeight,
            measuredHeightFt:
              measuredHeight !== null ? measuredHeight / FEET_TO_METERS : null,
          });
        }

        // Test 2: Set camera to Miami Beach (low elevation coastal area)
        testStatus.textContent = 'Moving camera to Miami Beach...';
        viewer.camera.setView({
          destination: Cesium.Cartesian3.fromDegrees(-80.13, 25.79, 50000),
          orientation: { heading: 0, pitch: -0.7, roll: 0 },
        });

        // Wait for terrain to load
        await new Promise((resolve) => setTimeout(resolve, 3000));

        // Test 3: Cycle through elevations and capture data
        for (const elevFt of TEST_ELEVATIONS) {
          testStatus.textContent = `Testing elevation: ${elevFt} ft...`;
          updateWaterLevel(elevFt);

          // Wait for render
          await new Promise((resolve) => setTimeout(resolve, 500));
          viewer.render();
          await new Promise((resolve) => setTimeout(resolve, 200));

          // Get terrain height at center
          let terrainHeightM = null;
          let terrainHeightFt = null;
          const ray = viewer.camera.getPickRay(
            new Cesium.Cartesian2(
              viewer.canvas.clientWidth / 2,
              viewer.canvas.clientHeight / 2,
            ),
          );
          if (ray) {
            const position = viewer.scene.globe.pick(ray, viewer.scene);
            if (position) {
              const cartographic = Cesium.Cartographic.fromCartesian(position);
              terrainHeightM = cartographic.height;
              terrainHeightFt = terrainHeightM / FEET_TO_METERS;
            }
          }

          // Try to get center pixel color
          let centerColor = null;
          try {
            centerColor = await getColorAtCenter();
          } catch (e) {
            centerColor = { error: e.message };
          }

          // Capture screenshot
          const screenshot = await captureScreenshot(`test_${elevFt}ft.png`);

          results.elevationTests.push({
            waterLevelFt: elevFt,
            waterLevelM: elevFt * FEET_TO_METERS,
            terrainHeightAtCenterM: terrainHeightM,
            terrainHeightAtCenterFt: terrainHeightFt,
            centerPixelColor: centerColor,
            screenshotDataUrl: screenshot.dataUrl,
          });
        }

        // Reset to 0
        updateWaterLevel(0);

        // Generate downloadable JSON report
        testStatus.textContent = 'Generating report...';

        // Create a version without screenshots for console logging
        const consoleResults = {
          ...results,
          elevationTests: results.elevationTests.map((t) => ({
            ...t,
            screenshotDataUrl: '[BASE64_IMAGE_DATA]',
          })),
        };
        console.log('=== DIAGNOSTIC TEST RESULTS ===');
        console.log(JSON.stringify(consoleResults, null, 2));

        // Create downloadable file
        const blob = new Blob([JSON.stringify(results, null, 2)], {
          type: 'application/json',
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'flooding_diagnostic_' + Date.now() + '.json';
        a.click();
        URL.revokeObjectURL(url);

        testStatus.textContent =
          'Test complete! Check console and downloaded JSON file.';
        runTestBtn.disabled = false;

        // Also log key findings
        console.log('=== KEY FINDINGS ===');
        console.log('Terrain heights at test locations:');
        results.locationTests.forEach((t) => {
          console.log(
            `  ${t.name}: Expected ${t.expectedElevFt}ft, Measured ${
              t.measuredHeightFt !== null
                ? t.measuredHeightFt.toFixed(1)
                : 'NULL'
            }ft`,
          );
        });
        console.log('Elevation band behavior:');
        results.elevationTests.forEach((t) => {
          const color = t.centerPixelColor;
          const colorStr = color.error
            ? color.error
            : `R:${color.r} G:${color.g} B:${color.b}`;
          console.log(
            `  ${t.waterLevelFt}ft: Terrain=${
              t.terrainHeightAtCenterFt !== null
                ? t.terrainHeightAtCenterFt.toFixed(1)
                : 'NULL'
            }ft, CenterColor=${colorStr}`,
          );
        });

        return results;
      }

      runTestBtn.addEventListener('click', runDiagnosticTest);
    </script>
  </body>
</html>
