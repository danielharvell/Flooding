<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Global Water Level Slider</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
    <link
      href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
      }
      #cesiumContainer {
        width: 100%;
        height: 100vh;
      }

      /* Full-width slider at top of screen */
      #sliderContainer {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        background: rgba(42, 42, 42, 0.9);
        padding: 0.75rem 1.5rem 1rem 1.5rem;
        z-index: 100;
        -webkit-backdrop-filter: blur(0.3125rem);
        backdrop-filter: blur(0.3125rem);
      }
      #sliderContainer input[type='range'] {
        width: 100%;
        margin: 0.5rem 0;
        height: 8px;
        cursor: pointer;
      }
      .slider-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.8em;
        color: #aaa;
      }
      .slider-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: white;
        margin-bottom: 0.25rem;
      }
      .slider-header h3 {
        margin: 0;
        font-size: 1em;
      }
      #currentHeight {
        font-weight: bold;
        color: #4db8ff;
        font-size: 1.2em;
      }

      /* Floating info panel (bottom-left) */
      #infoPanel {
        position: absolute;
        bottom: 1.25rem;
        left: 1.25rem;
        background: rgba(42, 42, 42, 0.8);
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        color: white;
        z-index: 100;
        -webkit-backdrop-filter: blur(0.3125rem);
        backdrop-filter: blur(0.3125rem);
        font-size: 0.85em;
      }

      /* Accessibility: visually hidden but screen reader accessible */
      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      #infoPanel p {
        margin: 0.25rem 0;
      }
      #changeTokenBtn {
        margin-top: 0.5rem;
        padding: 0.3rem 0.6rem;
        font-size: 0.75em;
        background: #555;
        color: #ccc;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      #changeTokenBtn:hover {
        background: #666;
      }
    </style>
  </head>
  <body>
    <!-- Info panel (bottom-left) -->
    <div id="infoPanel">
      <p><strong>Global Flooding Visualization</strong></p>
      <p>Use slider or ← → arrow keys (10ft steps)</p>
      <button type="button" id="changeTokenBtn">Change Cesium Token</button>
    </div>

    <!-- Full-width slider (bottom) -->
    <div id="sliderContainer">
      <div class="slider-header">
        <h3>Water Level</h3>
        <span id="currentHeight">0 ft</span>
      </div>
      <label for="heightSlider" class="visually-hidden"
        >Water Level Slider</label
      >
      <input
        type="range"
        id="heightSlider"
        min="-37417"
        max="30032"
        value="0"
        step="50"
        title="Adjust water level"
      />
      <div class="slider-labels">
        <span>-37,417 ft (Deep Ocean)</span>
        <span>+30,032 ft (Mt. Everest)</span>
      </div>
    </div>

    <div id="cesiumContainer"></div>

    <script>
      // 1. SETUP: Get Cesium token from local storage or prompt user
      const CESIUM_TOKEN_KEY = 'cesiumIonAccessToken';

      function getCesiumToken() {
        let token = localStorage.getItem(CESIUM_TOKEN_KEY);
        if (!token) {
          token = prompt(
            'Please enter your Cesium ion Access Token.\n\n' +
              'You can get a free token at: https://ion.cesium.com/tokens\n\n' +
              'This will be saved in your browser for future visits.',
          );
          if (token) {
            localStorage.setItem(CESIUM_TOKEN_KEY, token.trim());
          }
        }
        return token;
      }

      function clearCesiumToken() {
        localStorage.removeItem(CESIUM_TOKEN_KEY);
        location.reload();
      }

      const cesiumToken = getCesiumToken();
      if (!cesiumToken) {
        document.body.innerHTML =
          '<div style="padding: 20px; font-family: sans-serif;">' +
          '<h2>Cesium Token Required</h2>' +
          '<p>A Cesium ion access token is required to use this application.</p>' +
          '<p>Get a free token at: <a href="https://ion.cesium.com/tokens" target="_blank">https://ion.cesium.com/tokens</a></p>' +
          '<button onclick="location.reload()">Try Again</button>' +
          '</div>';
        throw new Error('No Cesium token provided');
      }

      Cesium.Ion.defaultAccessToken = cesiumToken;

      // 2. INITIALIZE VIEWER
      const viewer = new Cesium.Viewer('cesiumContainer', {
        baseLayerPicker: true,
        animation: false,
        timeline: false,
      });

      // Set terrain with Cesium World Bathymetry (asset ID 2426648)
      // This includes underwater ocean floor topography
      Cesium.CesiumTerrainProvider.fromIonAssetId(2426648, {
        requestWaterMask: true,
        requestVertexNormals: true,
      }).then(function (terrainProvider) {
        viewer.terrainProvider = terrainProvider;
      });

      // 3. ENABLE DEPTH TESTING
      viewer.scene.globe.depthTestAgainstTerrain = true;

      // 4. DATA LOGIC
      const FEET_TO_METERS = 0.3048;
      let waterHeightFeet = 0; // Starting at Sea Level (in feet)

      // 5. GEOID OFFSET ESTIMATION
      // CesiumJS terrain heights are relative to WGS84 ellipsoid, NOT mean sea level.
      // The geoid (mean sea level) differs from the ellipsoid by -100m to +100m globally.
      // This function estimates the geoid undulation based on latitude/longitude.
      // Uses a simplified model - accurate to ~10-20m in most areas.

      function estimateGeoidOffset(longitude, latitude) {
        // Simplified geoid undulation model based on global patterns
        // Values are in meters (positive = geoid above ellipsoid, negative = below)

        // Convert to radians for trig
        const lonRad = Cesium.Math.toRadians(longitude);
        const latRad = Cesium.Math.toRadians(latitude);

        // Major geoid features approximated with spherical harmonics
        // This captures the main trends: low in North America, high in Europe/Africa
        const n2_0 = -30.0 * (1.5 * Math.sin(latRad) * Math.sin(latRad) - 0.5);
        const n2_2 =
          15.0 * Math.cos(latRad) * Math.cos(latRad) * Math.cos(2 * lonRad);
        const n3_0 =
          -10.0 *
          Math.sin(latRad) *
          (2.5 * Math.sin(latRad) * Math.sin(latRad) - 1.5);

        // Combine terms
        let offset = n2_0 + n2_2 + n3_0;

        // Add regional corrections for known problem areas
        // North America tends to have more negative values
        if (
          longitude > -130 &&
          longitude < -60 &&
          latitude > 25 &&
          latitude < 55
        ) {
          offset -= 8; // Additional correction for CONUS
        }

        return offset;
      }

      // Get current camera position in cartographic coordinates
      function getCameraCartographic() {
        const cameraPosition = viewer.camera.positionCartographic;
        return {
          longitude: Cesium.Math.toDegrees(cameraPosition.longitude),
          latitude: Cesium.Math.toDegrees(cameraPosition.latitude),
        };
      }

      // Current geoid offset (updated when camera moves)
      let currentGeoidOffset = 0;

      // 6. ELEVATION BAND MATERIAL FOR TERRAIN-BASED FLOODING
      // This colors terrain below the water level with a blue overlay.
      // The key is using a gradient that transitions sharply at the water line.

      function createFloodMaterial(waterLevelMeters, geoidOffset) {
        // Apply geoid correction: convert sea level height to ellipsoid height
        // ellipsoidHeight = seaLevelHeight + geoidOffset
        // (geoidOffset is negative in North America, so this subtracts from water level)
        const ellipsoidWaterLevel = waterLevelMeters + geoidOffset;

        // Use a very deep minimum to cover all ocean floor
        const minElevation = -12000; // meters (about -39,000 ft)

        // Create elevation bands with a sharp transition at water level
        const layers = [
          {
            entries: [
              {
                height: minElevation,
                color: new Cesium.Color(0.0, 0.3, 0.8, 0.7), // Deep water blue
              },
              {
                height: ellipsoidWaterLevel - 10, // 10m below water line
                color: new Cesium.Color(0.0, 0.35, 0.85, 0.65),
              },
              {
                height: ellipsoidWaterLevel - 2, // Near water surface
                color: new Cesium.Color(0.0, 0.4, 0.9, 0.6),
              },
              {
                height: ellipsoidWaterLevel, // Water surface
                color: new Cesium.Color(0.0, 0.45, 0.95, 0.55),
              },
              {
                height: ellipsoidWaterLevel + 0.3, // Very sharp transition (0.3m = ~1ft)
                color: new Cesium.Color(0.0, 0.0, 0.0, 0.0), // Fully transparent
              },
            ],
            extendDownwards: true,
            extendUpwards: true,
          },
        ];

        return Cesium.createElevationBandMaterial({
          scene: viewer.scene,
          layers: layers,
        });
      }

      // Update geoid offset based on camera position
      function updateGeoidOffset() {
        const pos = getCameraCartographic();
        currentGeoidOffset = estimateGeoidOffset(pos.longitude, pos.latitude);
      }

      // Apply initial flood material (will be updated once camera is ready)
      viewer.scene.globe.material = createFloodMaterial(0, 0);

      // 6. UI INTERACTION
      const slider = document.getElementById('heightSlider');
      const label = document.getElementById('currentHeight');

      function formatNumber(num) {
        return num.toLocaleString('en-US');
      }

      function updateWaterLevel(feet, updateGeoid = false) {
        waterHeightFeet = feet;
        // Update geoid offset if requested (e.g., when camera moves)
        if (updateGeoid) {
          updateGeoidOffset();
        }
        // Convert feet to meters
        const waterHeightMeters = waterHeightFeet * FEET_TO_METERS;
        // Update the elevation band material with geoid correction
        viewer.scene.globe.material = createFloodMaterial(
          waterHeightMeters,
          currentGeoidOffset,
        );
        // Update the text label
        label.innerText = formatNumber(waterHeightFeet) + ' ft';
      }

      // Refresh flooding when camera moves (geoid offset changes by location)
      function onCameraMove() {
        updateGeoidOffset();
        const waterHeightMeters = waterHeightFeet * FEET_TO_METERS;
        viewer.scene.globe.material = createFloodMaterial(
          waterHeightMeters,
          currentGeoidOffset,
        );
      }

      slider.addEventListener('input', function () {
        updateWaterLevel(parseFloat(this.value));
      });

      // Keyboard arrow support for precise 10ft increments
      // Works when slider is focused OR when pressing arrows anywhere on page
      const ARROW_INCREMENT = 10; // feet
      const MIN_LEVEL = -37417;
      const MAX_LEVEL = 30032;

      function adjustWaterLevel(delta) {
        let newValue = waterHeightFeet + delta;
        newValue = Math.max(MIN_LEVEL, Math.min(MAX_LEVEL, newValue));
        slider.value = newValue;
        updateWaterLevel(newValue);
      }

      // Global keyboard listener for arrow keys
      document.addEventListener('keydown', function (e) {
        if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
          e.preventDefault();
          adjustWaterLevel(ARROW_INCREMENT);
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
          e.preventDefault();
          adjustWaterLevel(-ARROW_INCREMENT);
        }
      });

      // 7. LOCAL STORAGE FOR CAMERA POSITION & WATER LEVEL
      const STORAGE_KEY = 'floodingViewerState';

      function saveState() {
        const camera = viewer.camera;
        const state = {
          position: {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
          },
          heading: camera.heading,
          pitch: camera.pitch,
          roll: camera.roll,
          waterHeightFeet: waterHeightFeet,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }

      function loadState() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          try {
            const state = JSON.parse(saved);
            viewer.camera.setView({
              destination: new Cesium.Cartesian3(
                state.position.x,
                state.position.y,
                state.position.z,
              ),
              orientation: {
                heading: state.heading,
                pitch: state.pitch,
                roll: state.roll,
              },
            });
            // Restore water level
            if (state.waterHeightFeet !== undefined) {
              slider.value = state.waterHeightFeet;
              updateWaterLevel(state.waterHeightFeet);
            }
            return true;
          } catch (e) {
            console.warn('Failed to load saved state:', e);
          }
        }
        return false;
      }

      // Try to load saved state, otherwise default to Utah
      if (!loadState()) {
        viewer.camera.setView({
          destination: Cesium.Cartesian3.fromDegrees(-111.5, 39.5, 500000), // Utah
          orientation: {
            heading: 0.0,
            pitch: -0.7, // Looking down at an angle
            roll: 0.0,
          },
        });
      }

      // Initialize geoid offset based on starting camera position
      updateGeoidOffset();
      // Refresh flooding with correct geoid offset for initial position
      updateWaterLevel(waterHeightFeet, false);

      // Save state when camera moves or water level changes
      viewer.camera.moveEnd.addEventListener(saveState);
      // Update flooding when camera moves (geoid changes by location)
      viewer.camera.moveEnd.addEventListener(onCameraMove);
      slider.addEventListener('change', saveState);

      // Change token button
      document
        .getElementById('changeTokenBtn')
        .addEventListener('click', clearCesiumToken);
    </script>
  </body>
</html>
